# Run test on JMeter instances adding each instance to the mix after a delay

function usage() {
    cat <<-EOF

    Run test on JMeter instances adding each instance to the mix after a delay. This has the
    effect of gradually increasing the load over time. Once the last instance has been launched
    the tests are allowed to run for the delay time before stopping the test on each instance.

    Usage: $0 run-step-tests [options]
     -h, --help                     displays this help message
     -n, --name [NAME]              optional name of the test
     -d, --delay-minutes [DELAY]    optional delay in minutes, defaults to 5
     -r, --run-time-minutes [TIME]  optional time to run once all JMeter instances have started
     -j, --jvm-args [ARGS]          optional JVM Args to pass to JMeter ("-Xms512m -Xmx2048m" etc.)
     -f, --jmx-file [FILENAME]      optional name of JMX file to execute, file must already have been loaded on instances

     The name of a test will be lower cased and all whitespace replaced with underscores.

     If a script name is not provided the name of the current working directory will be used.

EOF
}

JVM_ARGS=
typeset -i DELAY=5
typeset -i RUN
while (( $# > 0 )); do
    key="$1"
    case $key in
        -h|--help)
            usage
            exit 0
            ;;
        -n|--name)
            set-test-name "$2"
            shift
            ;;
        -d|--delay-minutes)
            DELAY=$2
            shift
            ;;
        -r|--run-time-minutes)
            RUN=$2
            shift
            ;;
        -j|--jvm-args)
            JVM_ARGS=$2
            shift
            ;;
        -f|--jmx-file)
            SELECTED_JMX_FILE=$2
            shift
            ;;
        *)
            # Ignore or exit here
        ;;
    esac
    shift
done

# Convert minutes to seconds
typeset -i DELAY_SECONDS=${DELAY}*60


if [[ -z ${RUN} || ${RUN} < ${DELAY} ]]; then
    RUN=${DELAY}
fi

typeset -i RUN_TIME=${RUN}-${DELAY}
typeset -i RUN_TIME_SECONDS=${RUN_TIME}*60

# Name is optional if script is being run from the test directory
if [[ -z ${TEST_NAME} ]]; then
    if [[ -r ./config ]]; then
        set-test-name-from-cwd
    else
        error "You must provide a test name"
    fi
fi

if [[ ! -d ${TEST_DIR} ]]; then
    error "Test directory '${TEST_DIR}' does not exists."
fi

if [[ ! -z ${SELECTED_JMX_FILE} && ! -r ${DATA_DIR}/${SELECTED_JMX_FILE} ]]; then
    error "The JMX file specified has not been added. Try jm add-jmx."
fi

source ${TEST_DIR}/config
source ${CMD_DIR}/verify
source ${TEST_DIR}/jmeter

# Create the script that will be used to run JMeter inside Docker instance
cp ${RES_DIR}/run.sh ${WORK_DIR}/run_${TS}.sh
check $? "Unable to create working copy of run script"

chmod 755 ${WORK_DIR}/run_${TS}.sh
check $? "Unable to make working copy of run script executable"

JMX_TO_USE=${SELECTED_JMX_FILE:=${JMX_FILE}}

# Substitute values for place holders in run script
sed -i \
 -e "s|%TIMESTAMP%|${TS}|" \
 -e "s|%JMX_FILE%|${JMX_TO_USE}|" \
 -e "s|%TEST_NAME%|${TEST_NAME}|" \
 -e "s|%P12_FILE%|${P12_FILE}|" \
 ${WORK_DIR}/run_${TS}.sh
check $? "Unable to replace placeholders in working copy of run script"

PWD=""
if [[ ! -z ${P12_PASSWORD} ]]; then
    PWD="-e 'P12PWD=${P12_PASSWORD}'"
fi

JVMARGS=""
if [[ ${JVM_ARGS} ]]; then
    JVMARGS="-e 'JVM_ARGS=${JVM_ARGS}'"
fi

## At this point we have a conflict, we cannot Docker run with both -d and --rm!
## We really, really want --rm, so we have to settle for running docker in the
## background.

CMD="nohup docker run --rm \
${PWD} \
${JVMARGS} \
-v /home/ec2-user/${TEST_NAME}/log-dir:/logs \
-v /home/ec2-user/${TEST_NAME}/data-dir:/input_data \
-v /home/ec2-user/${TEST_NAME}/conf-dir:/jmconf \
--entrypoint '/input_data/run_${TS}.sh' \
--name '${TEST_NAME}' \
ordnancesurvey/jmeter:v1.0 > /home/ec2-user/${TEST_NAME}/log-dir/${TS}-docker.log 2>&1 &\
"

# Copy the file to all of the JMeter servers and start it running
for IP in ${JMETER_PUBLIC_IPS}; do
    scp -i ${AWS_PEM} -oStrictHostKeyChecking=no ${WORK_DIR}/run_${TS}.sh ec2-user@${IP}:/home/ec2-user/${TEST_NAME}/data-dir
    check $? "Problem copying run script to ${IP}"
    ssh -i ${AWS_PEM} -oStrictHostKeyChecking=no ec2-user@${IP} "${CMD}"
    check $? "Problem launching Docker JMeter on ${IP}"
    echo "Sleeping for ${DELAY} minutes (${DELAY_SECONDS} seconds) ...."
    sleep ${DELAY_SECONDS}
done

echo "Sleeping for ${RUN_TIME} minutes (${RUN_TIME_SECONDS} seconds) ...."
sleep ${RUN_TIME_SECONDS}

# Make a record of this test run
echo ${TS} >> ${TEST_DIR}/test-runs.log

# Stop the Docker containers on all machines
CMD="nohup docker stop ${TEST_NAME} >> /home/ec2-user/${TEST_NAME}/log-dir/${TS}-docker.log 2>&1 &"
for IP in ${JMETER_PUBLIC_IPS}; do
    ssh -i ${AWS_PEM} -oStrictHostKeyChecking=no ec2-user@${IP} "${CMD}"
    check $? "Problem terminating Docker JMeter on ${IP}"
done

echo "The logs generated by this run can be collected using process-logs."
echo "You can find a list of all test run keys in ${TEST_DIR}/test-runs.log"
echo "The key for this test is: ${TS}"
